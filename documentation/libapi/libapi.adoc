# Documentazione EvaApi
:toc: left
:source-highlighter: prettify 
include::../common/homelink.adoc[]

:numbered:

About
-----
Questa sessione presenterà e descriverà la libreria API nativa di EvangelionNG per effettuare chiamate di sistema (<<threads#SecurityLevels,livelli di sicurezza dei task>>)

AtomicLock
----------
Esegue un blocco atomico. se `atom` é `true` il task che ha eseguito questa chiamata verrà messo in blocco fino a che il kernel non lo ripristinerà.
Fino a che `atom` non torna `true` la chiamata non restituisce il controllo al flusso chiamante. 

Parametro: `atom`
		Flag usato per il blocco

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------
void AtomicLock(uint8_t *atom);
void AtomicLockDual(uint8_t *atom1, uint8_t *atom2);
----------------------------------------------------

AtomicTryLock
-------------
Prova ad eseguire un blocco atomico. Se il task è già in blocco la chiamata restituisce `false`, altrimenti il blocco è impostato come per <<AtomicLock, AtomicLock>> e la chiamata restituisce `true`.

Parametro: `atom`
		Flag usato per il blocco

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------
uint8_t AtomicTryLock(uint8_t *atom);
uint8_t AtomicTryLockDual(uint8_t *atom1, uint8_t *atom2);
----------------------------------------------------------

AtomicBlock
-----------
Esegue un blocco atomico. Se `atom` è `true` l'esecuzione del task è bloccata fino a che non è `atom` non è reimpostato a `false`. 
Differentemente da <<AtomicLock, AtomicLock>> `atom` non viene modificato automaticamente dal kernel (Con questa chiamata si possono creare applicazioni a eventi).

Parametro: `atom`
		Flag usato per il blocco

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------------------------------
void AtomicBlock(uint8_t *atom);
void AtomicBlockDual(uint8_t *atom1, uint8_t *atom2);
-----------------------------------------------------

Spawn
-----
Lancia un programma eseguibile. 

Parametro: `path`
		Percorso assoluto all'eseguibile

Parametro: `args`
		Argomenti

Parametro: `workdir`
		Directory base per il processo

Parametro: `securityLevel`
		livello di sicurezza con cui lanciare il programma (da user solo APPLICATION)

Parametro: `pid`
		viene riempito con il Pid del processo creato

Parametro: `outStdio`
		é riempito con i file di standard I/O, la posizione 0 è write e stdin,
		la 1 è read e stdout, infine la 2 é read e stderr

Parametro: `inStdio`
		se fornito, the given descriptors which are valid for the executing process
		are used as the stdin/out/err for the spawned process; an entry might be -1
		to be ignored and default behaviour being applied

Ritorno: one of the `SpawnStatus` codes

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------------------------------------------------------------------------------------------------
SpawnStatus Spawn(const char *path, const char *args, const char *workdir, SecurityLevel securityLevel);
SpawnStatus SpawnP(const char *path, const char *args, const char *workdir, SecurityLevel securityLevel, Pid *pid);
SpawnStatus SpawnPO(const char *path, const char *args, const char *workdir, SecurityLevel securityLevel, Pid *pid, Fd outStdio[3]);
SpawnStatus SpawnPOI(const char *path, const char *args, const char *workdir, SecurityLevel securityLevel, Pid *pid, Fd outStdio[3], Fd inStdio[3]);
----------------------------------------------------------------------------------------------------------------------------------------------------

Kill
-----
Termina un processo.

Parametro: `pid`
		l'identificatore del processo

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------
KillStatus Kill(Pid pid);
-------------------------

Log
---
Stampa un messaggio sulla porta seriale.

Parametro: `message`
		Il messaggio da scrivere

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------------
void Log(const char *message);
------------------------------

syscall
-------
Esegue l'interrupt necessario perchè venga eseguita la chiamata di sistema con il passaggio di dati.

Parametro: `call`
		La chiamata da esegurie

Parametro: `data`
		I dati necessari alla chiamata (puntatore a struttura dati)

Clobber `flag` (di più: https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html): 

- Il clobber `cc` indica che il codice assembler modifica i flag dei registri 

- Il clobber `memory` dice al compilatore che il codice assembly legge o scrive in memoria elementi diversi da quelli elencati dagli operandi di ingresso e di uscita. 

Indica al GCC che qualcosa nella memoria cambia (la chiamata di sistema potrebbe farlo).

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------------------
void Syscall(uint32_t call, uint32_t data);
-------------------------------------------

Open
----
Apre un file.

Parametro: `path`
		Il percorso al file

Parametro: `flags`
		Flag per la modalità di apertura

Parametro: `outStatus`
		Riempito con una delle costanti `FsOpenStatus`

Ritorno: Il descrittore del file aperto

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------------------------------------------------------------
Fd Open(const char *path);
Fd OpenF(const char *path, int32_t flags);
Fd OpenFS(const char *path, int32_t flags, FsOpenStatus *outStatus);
Fd OpenFMS(const char *path, int32_t flags, int32_t mode, FsOpenStatus *outStatus);
-----------------------------------------------------------------------------------

Close
-----
Chiude un file.

Parametro: `fd`
		Il descrittore del file da chiudere

Ritorno: Una delle costanti `FsCloseStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------------
FsCloseStatus Close(Fd fd);
---------------------------

Length
------
Ritorna la dimensione del file in `byte` passando il descrittore del file.

Parametro: `fd`
		Il descrittore del file

Parametro: `outStatus`
		Riempito con una delle costanti `FsLengthStatus`

Ritorno: the length in bytes

Livello Sicurezza: `APPLICATION`
[source,c]
--------------------------------------------------
int64_t Length(Fd fd);
int64_t LengthS(Fd fd, FsLengthStatus *outStatus);
--------------------------------------------------

OpenDirectory
--------------
Apre una directory.

Parametro: `path`
		Percorso alla cartella

Ritorno: puntatore all'iteratore della directory, 0 se l'apertura fallisce
[source,c]
----------------------------------------------------------------------------------------
FsDirectoryIterator *OpenDirectory(const char *path);
FsDirectoryIterator *OpenDirectoryS(const char *path, FsOpenDirectoryStatus *outStatus);
----------------------------------------------------------------------------------------

ReadDirectory
-------------
Legge la entry successiva dell'iteratore della directory.

Parametro: `iterator`
		L'iteratore della cartella

Parametro: `outStatus`
		Riempito con una delle costanti `FsReadDirectoryStatus`

Ritorno: a directory entry structure, or 0 if not successful
[source,c]
--------------------------------------------------------------------------------------------------
FsDirectoryEntry *ReadDirectory(FsDirectoryIterator *iterator);
FsDirectoryEntry *ReadDirectoryS(FsDirectoryIterator *iterator, FsReadDirectoryStatus *outStatus);
--------------------------------------------------------------------------------------------------

CloseDirectory
--------------
Chiude una directory.

Parametro: `iterator`
		L'iteratore della directory
[source,c]
---------------------------------------------------
void CloseDirectory(FsDirectoryIterator *iterator);
---------------------------------------------------

Flengt
------
Ritorna la dimensione del file in `byte` passando il percorso del file.

Parametro: `path`
		Percorso al file

Parametro: `followSymlinks`
		Booleano che indica se sono presenti collegamenti simbolici

Parametro: `outStatus`
		Riempito con una delle costanti `FsLengthStatus`

Ritorno: the length in bytes

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------------------------------------------------------------------------
int64_t Flength(const char *path);
int64_t FlengthS(const char *path, uint8_t followSymlinks);
int64_t FlengthSS(const char *path, uint8_t followSymlinks, FsLengthStatus *outStatus);
---------------------------------------------------------------------------------------

Seek
----
Riposiziona l'offset all'interno di un file.

Parametro: `fd`
		Il descrittore del file

Parametro: `off`
		l'offset

Parametro: `outStatus`
		Riempito con una delle costanti `FsSeekStatus`

Parametro: `mode`
		Una delle costanti `FsSeekMode`

Ritorno: se la chiamata ha successo ritorna l'offset assoluto, altrimenti -1

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------------------------
int64_t Seek(Fd fd, int64_t off, FsSeekMode mode);
int64_t SeekS(Fd fd, int64_t off, FsSeekMode mode, FsSeekStatus *outStatus);
----------------------------------------------------------------------------

Tell
----
Ritorna l'offset corrente di un file.

Parametro: `fd`
		Il descrittore del file

Parametro: `outStatus`
		Riempito con una delle costanti `FsTellStatus`

Ritorno: se la chiamata ha successo ritorna l'offset assoluto corrente, altrimenti -1

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------
int64_t Tell(Fd fd);
int64_t TellS(Fd fd, FsTellStatus *outStatus);
----------------------------------------------

SetWorkingDirectory
-------------------
Imposta la cartella corrente del processo che esegue la chiamata.

Parametro: `path`
		Buffer di al massimo `PATH_MAX` byte che contiene la nuova directory

Parametro: `process`
		Processo a cui viene impostata la directory corrente durante lo <<Spawn, Spawn>>

Ritorno: Una delle costanti `SetWorkingDirectoryStatus`

Livello Sicurezza: `APPLICATION` se nessun processo è fornito, altrimenti `KERNEL`
[source,c]
----------------------------------------------------------------------------------------------------
SetWorkingDirectoryStatus SetWorkingDirectory(const char *path);
SetWorkingDirectoryStatus SetWorkingDirectoryP(const char *path, ProcessCreationIdentifier process);
----------------------------------------------------------------------------------------------------

GetWorkingDirectory
-------------------
Ritorna la directory corrente del processo che esegue la chiamata

Parametro: `path`
		Buffer di al massimo di `maxlen` o `PATH_MAX` byte

Parametro: `maxlen`
		length of the buffer in bytes

Ritorno: Una delle costanti `GetWorkingDirectoryStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------------------------
GetWorkingDirectoryStatus GetWorkingDirectory(char *buffer);
GetWorkingDirectoryStatus GetWorkingDirectoryL(char *buffer, size_t maxlen);
----------------------------------------------------------------------------

GetExecutablePath
-----------------
Ritorna la direcotory dell'eseguibile quando disponibile (es. lo <<EvangelionNG#Spawner, Spawner>> non ha directory), altrimenti una stringa vuota.

Parametro: `path`
		Buffer allocato di al massimo `PATH_MAX` byte

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------------
void GetExecutablePath(char *buffer);
-------------------------------------

Read
----
Legge byte dal file e li scrive sul buffer.

Parametro: `fd`
		Il descrittore del file

Parametro: `buffer`
		Il buffer dove scrive ciò che la chiamata legge

Parametro: `length`
		Numero di byte da leggere

Parametro: `outStatus`
		Una delle costanti `FsReadStatus`

Ritorno: se la chiamata ha successo il numero di byte letti, 0 se EOF, -1 se la chiamata è fallita

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------------------------------------------------------
int32_t Read(Fd fd, void *buffer, uint64_t length);
int32_t ReadS(Fd fd, void *buffer, uint64_t length, FsReadStatus *outStatus);
-----------------------------------------------------------------------------

Write
-----
Scrive byte dal buffer al file.

Parametro: `fd`
		Il descrittore del file

Parametro: `buffer`
		Il buffer contenente i byte da scrivere

Parametro: `length`
		La dimensione del buffer

Parametro: `outStatus`
		Una delle costanti `FsWriteStatus`

Ritorno: if successful the number of bytes that were written, otherwise -1

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------------------------------------------------------------
int32_t Write(Fd fd, const void *buffer, uint64_t length);
int32_t WriteS(Fd fd, const void *buffer, uint64_t length, FsWriteStatus *outStatus);
-------------------------------------------------------------------------------------

GetMessageTxId
--------------
Ritorna il prossimo identificatore di transazione usato per messaggi
Quando viene inviato un messaggio un identificatore di messaggio può essere aggiunto cosicchè un'altro Thread può aspettare un messaggio con uno stesso identificatore. 
Questa chiamata restituisce sempre un nuovo ID così da salvaguardare i Thread.

Ritorno: un nuovo identificatore di transazione

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------------------
MessageTransaction GetMessageTxId();
------------------------------------

AllocMem
--------
Alloca una regione di memoria della dimensione fornita. 
La regione allocata può essere usata per la condivisione di memoria.

L'allocazione di memoria utilizzando questa chiamata rende il processo che richiede il proprietario delle pagine fisiche nel suo spazio virtuale (importante per unmapping).

Parametro: `size`
		dimensione in byte

Ritorno: un puntatore all'area allocata, `nullptr` se la chiamata fallisce

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------
void *AllocMem(int32_t size);
-----------------------------

ShareMem
--------
Condivide una zona di memoria con un altro processo.

Parametro: `memory`
		Il puntatore all'area da condividere

Parametro: `size`
		La dimensione dell'area

Parametro: `pid`
		L'identificatore del processo

Ritorno: un puntatore all'area di memoria condivisa con l'altro processo

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------
void *ShareMem(void *memory, int32_t size, Pid pid);
----------------------------------------------------

Yield
-----
Richiama lo Scheduler e causa lo switch al prossimo processo.

Livello Sicurezza: `APPLICATION`
[source,c]
-------------
void Yield();
-------------

Sleep
-----
Blocca l'esecuzione del processo per il numero fornito di millisecondi.

Parametro: `ms`
		Il numero di millisecondi

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------
void Sleep(uint64_t ms);
------------------------

GetPid
------
Ritorna il Pid del processo corrente.

Ritorno: il pid del processo

Livello Sicurezza: `APPLICATION`
[source,c]
------------------
uint32_t GetPid();
------------------

GetTid
------
Ritorna il Tid del thread corrente, se il thread che esegue la chiamata è il main il Tid è uguale al Pid.

Ritorno: il Tid del thread corrente

Livello Sicurezza: `APPLICATION`
[source,c]
------------------
uint32_t GetTid();
------------------

GetPidForTid
------------
Ritorna il Pid del processo dal Tid del thread che esegue la chiamata.

Parametro: `tid` Tid del thread

Ritorno: il Pid del processo

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------------------
uint32_t GetPidForTid(uint32_t tid);
------------------------------------

Exit
----
Termina il processo corrente con il codice fornito.

Parametro: `status`
		codice di terminazione

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------
void Exit(int status);
----------------------

CreateThread
------------
Crea un thread che viene aggiunto al processo corrente (<<threads#Creazione Thread, Gestione e creazione thread>>).

Parametro: `function`
		funzione del thread

Parametro: `userData`
		puntatore ai parametri per `function`

Ritorno: Tid del thread creato

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------------------------------
Tid CreateThread(void *function);
Tid CreateThreadD(void *function, void *userData);
Tid CreateThreadDS(void *function, void *userData, CreateThreadStatus *outStatus);
----------------------------------------------------------------------------------

SendMessage
-----------
Invia un messaggio al task di cui viene fornito il Tid. Inviare un messaggio significa copiare i `length` byte del `buffer` nella coda dei messaggi del processo ricevente.
Il messaggio non può superare la dimensione di `MESSAGE_MAXIMUM_LENGTH`.

Parametro: `target`
		Tid del thread a cui inviare il messaggio

Parametro: `buffer`
		messaggio

Parametro: `length`
		dimensione del messaggio

Parametro: `mode`
 specifica come la chiamata debba bloccare il task che la richiama:

- `MESSAGE_SEND_MODE_BLOCKING` il task che invia il messaggio deve bloccarsi se il ricevente ha la coda piena (é la modalità di default)

- `MESSAGE_SEND_MODE_NON_BLOCKING` la funzione ritorna `MESSAGE_SEND_STATUS_QUEUE_FULL` se il ricevente ha la coda piena

Parametro: `tx`
		identificatore di transazione

Ritorno: Una delle costanti `MessageSendStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------------------------------------------------------------------------------------------
MessageSendStatus SendMessage(Tid target, void *buffer, size_t length);
MessageSendStatus SendMessageM(Tid target, void *buffer, size_t length, MessageSendMode mode);
MessageSendStatus SendMessageT(Tid tid, void *buffer, size_t length, MessageTransaction tx);
MessageSendStatus SendMessageTM(Tid tid, void *buffer, size_t length, MessageTransaction tx, MessageSendMode mode);
-------------------------------------------------------------------------------------------------------------------

ReceiveMessage
--------------
Riceve un messaggio. Vengono copiati `max` byte in `buffer`.

Se la chiamata ha successo buffer conterrà l'header del messaggio piu il contenuto.

- per accedere all'header si usi sempre il buffer facendo un cast: ((MessageHeader *buffer)
- per accedere al contenuto si usi la macro:  MESSAGE_CONTENT(buffer);

When a transaction ID is given, only messages that were sent with the same
transaction ID will be received.

Parametro: `buffer`
		Output buffer

Parametro: `max`
		Dimensione massima del buffer

Parametro: `mode` specifica come la chiamata debba bloccare il task che la richiama:

- `MESSAGE_RECEIVE_MODE_BLOCKING` il task che esegue la chiamata deve bloccarsi se non ci sono messaggi

- `MESSAGE_RECEIVE_MODE_NON_BLOCKING` la funzione ritorna `MESSAGE_RECEIVE_STATUS_QUEUE_EMPTY` se la coda di messaggi in ricezione è vuota

Parametro: `tx`
		identificatore di transazione

Parametro: `breakCondition`
		può essere usato per interrompere il blocco del thread in ricezione impostando `true`

Ritorno: Una delle costanti `MessageReceiveStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------------------------------------------------------------------------------------------------------------------------
MessageReceiveStatus ReceiveMessage(void *buffer, size_t max);
MessageReceiveStatus ReceiveMessageM(void *buffer, size_t max, MessageReceiveMode mode);
MessageReceiveStatus ReceiveMessageT(void *buffer, size_t max, MessageTransaction tx);
MessageReceiveStatus ReceiveMessageTM(void *buffer, size_t max, MessageTransaction tx, MessageReceiveMode mode);
MessageReceiveStatus ReceiveMessageTMB(void *buffer, size_t max, MessageTransaction tx, MessageReceiveMode mode, uint8_t *breakCondition);
---------------------------------------------------------------------------------------------------------------------------------------

TaskRegisterID
--------------
Registra il nome del thread (il main viene automaticamente registrato con il nome dell'eseguibile).

Parametro: `identifier`
		Il nome da impostare

Ritorno: se il nome è disponibile `true`, altrimenti `false`

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------------------------
uint8_t TaskRegisterID(const char *identifier);
-----------------------------------------------

TaskGetID
---------
Ritorna il Tid del task registrato con il nome fornito.

Parametro: `identifier`
		il nome da ricercare

Ritorno: Tid del thread con quel nome, -1 se non esiste nessun thread a quel nome

Livello Sicurezza: `APPLICATION`
[source,c]
--------------------------------------
Tid TaskGetID(const char *identifier);
--------------------------------------

WaitForIrq
----------
Il thread in esecuzione attende fino a che non si verifica un interrupt request con il numero fornito.

Parametro: `irq`
		L'interrupt Request fornita

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------------
void WaitForIrq(uint8_t irq);
-----------------------------

MapMmio
-------
Mappa l'indirizzo fisico fornito nello spazio di indirizzamento del processo in esecuzione cosicchè possa accedervi direttamente

Parametro: `address`
		L indirizzo fisico che si desidera mappare

Parametro: `size`
		La dimensione della mappatura

Ritorno: un puntatore all'area mappata entro gli indirizzi del processo

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------------------------
void *MapMmio(void *address, uint32_t size);
-----------------------------------------

Unmap
-----
De-mappa l'area di memoria fornita.

Parametro: `area`
		il puntatore all'area di memoria da deallocare

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------
void Unmap(void *area);
-----------------------

Sbrk
----
Modifica la dimensione dell'heap del processo.

Parametro: `amount`
		Il valore con cui modificare l'heap

Parametro: `outBrk`
		Riempito con il risultato

Ritorno: booleano che attesta il successo della chiamata

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------
uint8_t Sbrk(int amount, void **outBrk);
----------------------------------------

CallVm86
--------
Esegue una chiamata virtuale al bios 8086

Parametro: `interrupt`
		indentificatore dell'interrupt da eseguire

Parametro: `in`
		Registri in input

Parametro: `out`
		Registri in output

Ritorno: Una delle costanti `Vm86CallStatus`

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------------------------------------------------------------------
Vm86CallStatus CallVm86(uint32_t interrupt, Vm86Registers *in, Vm86Registers *out);
-----------------------------------------------------------------------------------

LowerFree
---------
Libera memoria allocata con <<LowerMalloc, LowerMalloc>>.

Parametro: `memory`
		Puntatore all'area da deallocare

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------------
void LowerFree(void *memory);
-----------------------------

LowerMalloc
-----------
Alloca un'area di memoria lower. Può essere usato
per esempio per la modalità 8086 virtuale.

Parametro: `size`
		Dimensione dell'allocazione

Livello Sicurezza: `DRIVER`
[source,c]
---------------------------------
void *LowerMalloc(uint32_t size);
---------------------------------

SetVideoLog
-----------
Abilita o disabilita i log sulla porta seriale

Parametro: `enabled`
		Flag booleano per abilitare o disabilitare i log

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------
void SetVideoLog(uint8_t enabled);
----------------------------------

RamdiskSpawn
------------
Lancia un eseguibile da RamDisk (Usata solo da init per eseguire lo <<EvangelionNG#Spawner, Spawner>>).

Parametro: `path`
		Percorso relativo all'eseguibile

Parametro: `securityLevel`
		Il livello di sicurezza che dovrà avere il processo lanciato

Parametro: `security-level KERNEL`
[source,c]
-------------------------------------------------------------------------------
RamdiskSpawnStatus RamdiskSpawn(const char *path, SecurityLevel securityLevel);
-------------------------------------------------------------------------------

RamdiskFind
-----------
Trova il descrittore del file su RamDisk da un percorso assoluto.

Parametro: `path`
		percorso assoluto

Ritorno: Il descrittore del file, altrimenti -1

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------
int RamdiskFind(const char *path);
----------------------------------

RamdiskFindChild
----------------
Trova l'entry relativa all'ID su RamDisk tramite il percorso realtivo

Parametro: `nodeID`
		inode del percorso specificato

Parametro: `childName`
		percorso relativo

Ritorno: if found the ramdisk node id, otherwise -1

Livello Sicurezza: `APPLICATION`
[source,c]
--------------------------------------------------------
int RamdiskFindChild(int nodeID, const char *childName);
--------------------------------------------------------

RamdiskInfo
-----------
Ritorna la entry del RamDisk del descrittore fornito

Parametro: `nodeID`
		descrittore del nodo del RamDisk

Parametro: `out`
		Viene riempito con la entry

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------
void RamdiskInfo(int nodeID, RamdiskEntryInfo *out);
----------------------------------------------------

RamdiskRead
-----------
Legge length byte dal descrittore di file su RamDisk fornito.

Parametro: `nodeID`
		descrittore file su RamDisk

Parametro: `offset`
		Offset del file

Parametro: `buffer`
		Buffer riempito con i byte letti

Parametro: `length`
		Numero di byte d leggere

Ritorno: se la lettura ha successo il numero di byte letti, -1 altrimenti

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------------------------------------------------
int RamdiskRead(int nodeID, uint32_t offset, char *buffer, uint32_t length);
----------------------------------------------------------------------------

RamdiskChildCount
-----------------
Ritorna il numero di figli di un nodo fornito

Parametro: `nodeID`
		descrittore del file su RamDisk

Ritorno: il numero di figli

Livello Sicurezza: `APPLICATION`
[source,c]
----------------------------------
int RamdiskChildCount(int nodeID);
----------------------------------

RamdiskChildAt
--------------
Ritorna l'id di un figlio del nodo all'indice fornito.

Parametro: `nodeID`
		descrittore file su RamDisk

Parametro: `index`
		Indice del figlio

Ritorno: se il figlio esiste il suo id, altrimenti -1

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------------------------
int RamdiskChildAt(int nodeID, int index);
------------------------------------------

Millis
------
Ritorna il numero di millisecondi trascorsi dall'avvio dello Scheduler corrente.

Ritorno: numero di millisecondi

Livello Sicurezza: `APPLICATION`
[source,c]
------------------
uint64_t Millis();
------------------

Test
----
Chiamata di test per il debug del kernel.

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------------------
uint32_t Test(uint32_t test);
-----------------------------

Fork
----
Esegue il fork del processo corrente.
TODO:
	- Funziona solo con il thread main

Ritorno: Ritorna al processo creato il suo id, 0 al task che ha eseguito la chiamata

Livello Sicurezza: `APPLICATION`
[source,c]
-----------
Tid Fork();
-----------

Join
----
Entra nel task di cui è fornito il Tid. Il task che ha eseguito la chiamata rimarrà in blocco fino a che il task richiamato non terminerà

Parametro: `tid`
		Tid del task in cui entrare

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------
void Join(Tid tid);
------------------------

CloneFd
-------
Clona un descrittore di file di un task dentro a un nuovo task. Crea un nuovo descrittore di file nel task in cui vengono clonati

Parametro: `sourceFd`
		descrittore del file da clonare

Parametro: `sourcePid`
		Pid del task di cui clonare il descrittore

Parametro: `targetPid`
		Pid del task in cui clonare il descrittore

Parametro: `outStatus`
		Riempito con una delle costanti `FsClonefdStatus`

Ritorno: Il descrittore creato nel task target

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------------------------------------------------------------------
Fd CloneFd(Fd sourceFd, Pid sourceProcess, Pid targetProcess);
Fd CloneFdS(Fd sourceFd, Pid sourceProcess, Pid targetProcess, FsClonefdStatus *outStatus);
-------------------------------------------------------------------------------------------

CloneFdT
--------
Clona il descrittore del file di un task in un descrittore esistente di un'altro task.

Parametro: `sourceFd`
		descrittore del file da clonare

Parametro: `sourcePid`
		Tid del task che deve clonare il descrittore

Parametro: `targetFd`
		descrittore del file in cui clonare

Parametro: `targetPid`
		Tid del task

Parametro: `outStatus`
		Riempito con una delle costanti `FsClonefdStatus`

Ritorno: Il descrittore nel task target

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------------------------------------------------------------------------------------------
Fd CloneFdT(Fd sourceFd, Pid sourceProcess, Fd targetFd, Pid targetProcess);
Fd CloneFdTS(Fd sourceFd, Pid sourceProcess, Fd targetFd, Pid targetProcess, FsClonefdStatus *outStatus);
---------------------------------------------------------------------------------------------------------

Pipe
----
Apre una pipe.

Parametro: `outWrite`
		Riempito con il descrittore della pipe in scrittura

Parametro: `outRead`
		Riempito con il descrittore della pipe in lettura

Parametro: `outStatus`
		Riempito con una delle costanti `FsPipeStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------------------------------------------------
void Pipe(Fd *outWrite, Fd *outRead);
void PipeS(Fd *outWrite, Fd *outRead, FsPipeStatus *outStatus);
---------------------------------------------------------------

CliArgsStore
------------
Copia nel processo in creazione fornito gli argomenti

Parametro: `process`
		L'indentificatore del processo in creazione

Parametro: `arguments`
		Argomenti per il processo

Livello Sicurezza: `KERNEL`
[source,c]
----------------------------------------------------------------------
void CliArgsStore(ProcessCreationIdentifier process, char *arguments);
----------------------------------------------------------------------

CliArgsRelease
--------------
Ritorna nel buffer gli argomenti del processo in esecuzione.
Questo buffer può avere una dimensione massima di `PROCESS_COMMAND_LINE_ARGUMENTS_BUFFER_LENGTH` byte.
Se non sono stati forniti argomenti il buffer conterrà solo il carattere di terminazione.

Parametro: `buffer`
		Buffer dove verranno copiati gli argomenti

Livello Sicurezza: `KERNEL`
[source,c]
----------------------------------
void CliArgsRelease(char *buffer);
----------------------------------

CreateEmptyProcess
------------------
Crea un nuovo descrittore di processo non configurato.

Parametro: `securityLevel`
		Livello di sicurezza del processo

Ritorno: l'identificatore del processo in creazione

Livello Sicurezza: `KERNEL`
[source,c]
--------------------------------------------------------------------------
ProcessCreationIdentifier CreateEmptyProcess(SecurityLevel securityLevel);
--------------------------------------------------------------------------

ConfigureProcess
----------------
Configura il processo in creazione fornito.

Parametro: `process`
		Descrittore del processo in creazione

Parametro: `configuration`
		Struttura contenente i dati di configurazione

Livello Sicurezza: `KERNEL`
[source,c]
---------------------------------------------------------------------------------------------
void ConfigureProcess(ProcessCreationIdentifier process, ProcessConfiguration configuration);
---------------------------------------------------------------------------------------------

CreatePagesInSpaces
--------------------
Crea pagine di memoria per un processo in creazione e mappa le pagine create nel processo in esecuzione.

Parametro: `process`
		Identificatore del processo in creazione

Parametro: `virtualAddress`
		L'indirizzo di inizio per la mappatura

Parametro: `pages`
		Numero di pagine da creare

Ritorno: l'indirizzo virtuale delle pagine mappate per il processo nel suo spazio di indirizzi

Livello Sicurezza: `KERNEL`
[source,c]
-------------------------------------------------------------------------------------------------
void *CreatePagesInSpaces(ProcessCreationIdentifier process, uint32_t virtualAddress, int pages);
-------------------------------------------------------------------------------------------------

WriteTlsMasterForProcess
------------------------
Crea un'area di storage locale al thread per il processo in creazione per la copia di content

Parametro: `process`
		Identificatore del processo in creazione

Parametro: `content`
		Contenuto della copia master

Parametro: `copySize`
		Quantità di byte da copiare dal buffer content

Parametro: `totalSize`
		Grandezza totale (inclusi i byte a zero)

Parametro: `alignment`
		alineamento del tls

Ritorno: booleano indicante il successo dell'operazione

Livello Sicurezza: `KERNEL`
[source,c]
-------------------------------------------------------------------------------------------------------------------------------------------------
uint8_t WriteTlsMasterForProcess(ProcessCreationIdentifier process, uint8_t *content, uint32_t copySize, uint32_t totalSize, uint32_t alignment);
-------------------------------------------------------------------------------------------------------------------------------------------------

AttachCreatedProcess
--------------------
Attribuisce un punto di inizio esecuzione al processo in creazione.

Parametro: `process`
		Identificatore del processo in creazione

Parametro: `eip`
		Indirizzo del punto di inizio esecuzione

Livello Sicurezza: `KERNEL`
[source,c]
---------------------------------------------------------------------------
void AttachCreatedProcess(ProcessCreationIdentifier process, uint32_t eip);
---------------------------------------------------------------------------

CancelProcessCreation
---------------------
Ferma la creazione del processo.

Parametro: `process`
		Identificatore del processo in creazione

Livello Sicurezza: `KERNEL`
[source,c]
--------------------------------------------------------------
void CancelProcessCreation(ProcessCreationIdentifier process);
--------------------------------------------------------------

GetCreatedProcessID
-------------------
Ritorna il Pid del processo appena creato. Usabile solo se è già stata effettuata la chiamata a <<AttachCreatedProcess, AttachCreatedProcess>>

Parametro: `process`
		Identificatore del processo in creazione

Ritorno: Pid del processo creato.

Livello Sicurezza: `KERNEL`
[source,c]
-----------------------------------------------------------
Pid GetCreatedProcessID(ProcessCreationIdentifier process);
-----------------------------------------------------------

FsRegisterAsDelegate
--------------------
Crea un mountpoint e registra il thread corrente come delegato del filesystem.

Parametro: `name`
		Nome del mountpoint

Parametro: `physMountpointID`
		L'id fisico del mountpoint

Parametro: `outMountpointID`
		é riempito con l'id del nodo se il mountpoint viene creato con successo

Parametro: `outTransactionStorage`
		é riempito con l'indirizzo per le transazioni

Ritorno: una delle costanti `FsRegisterAsDelegateStatus`

Livello Sicurezza: `DRIVER`
[source,c]
--------------------------------------------------------------------------------------------------------------------------------------------------------
FsRegisterAsDelegateStatus FsRegisterAsDelegate(const char *name, FsPhysID physMountpointID, FsVirtID *outMountpointID, Address *outTransactionStorage);
--------------------------------------------------------------------------------------------------------------------------------------------------------

FsSetTransactionStatus
----------------------
Aggiorna lo stato di una transazione sul filesystem.

Parametro: `id`
		Identificatore della transazione

Parametro: `status`
		Stato della transazione

Livello Sicurezza: `DRIVER`
[source,c]
----------------------------------------------------------------------------
void FsSetTransactionStatus(FsTransactionID id, FsTransactionStatus status);
----------------------------------------------------------------------------

FsCreateNode
------------
Crea un nuovo nodo nel filesystem.

Parametro: `parent`
		Identificatore del nodo padre

Parametro: `name`
		Nome del nodo

Parametro: `type`
		Uno dei tipi di FsNodeType

Parametro: `fsID`
		L'identificatore del filesystem per il nodo

Parametro: `outCreatedID`
		Riempito con l'identificatore del nodo creato

Ritorno: una delle costanti `FsCreateNodeStatus`

Livello Sicurezza: `DRIVER`
[source,c]
---------------------------------------------------------------------------------------------------------------------
FsCreateNodeStatus FsCreateNode(uint32_t parent, char *name, FsNodeType type, uint64_t fsID, uint32_t *outCreatedID);
---------------------------------------------------------------------------------------------------------------------

RegisterIrqHandler
------------------
Registra la funzione `handler` come gestore dell'interrupt request `irq`.

Parametro: `irq`
		Numero dell'interrupt

Parametro: `handler`
		Funzione da richiamare

Ritorno: una delle costanti `RegisterIrqHandlerStatus`

Livello Sicurezza: `DRIVER`
[source,c]
-----------------------------------------------------------------------------------
RegisterIrqHandlerStatus RegisterIrqHandler(uint8_t irq, void (*handler)(uint8_t));
-----------------------------------------------------------------------------------

RestoreInterruptedState
-----------------------
Ristabilisce l'esecuzione del thread dallo stato di interruption (per esempio dopo un segnale o un'interrupt request)

Livello Sicurezza: `DRIVER`
[source,c]
-------------------------------
void RestoreInterruptedState();
-------------------------------

RegisterSignalHandler
---------------------
Registra la funzione `handler` come gestore del segnale.

Parametro: `signal`
		Segnale da gestire

Parametro: `handler`
		Funzione da richiamare

Ritorno: Gestore registrato precedentemente

Livello Sicurezza: `DRIVER`
[source,c]
-------------------------------------------------------
void *RegisterSignalHandler(int signal, void *handler);
-------------------------------------------------------

RaiseSignal
-----------
lancia `signal` a `process`.

Parametro: `process`
		Processo target

Parametro: `signal`
		Numero del segnale

Ritorno: una delle costanti `RaiseSignalStatus`

Livello Sicurezza: `DRIVER`
[source,c]
-------------------------------------------------------
RaiseSignalStatus RaiseSignal(Pid process, int signal);
-------------------------------------------------------

EvaQuery
--------
Richiama il kernel per eseguire una delle chiamate passate come comando

Parametro: `command`
		comando della chiamata

Parametro: `query`
		parametry della chiamata

Parametro: `outbuffer`
		output buffer

Ritorno: una delle costanti `EvaQueryStatus`

Livello Sicurezza: `APPLICATION`
[source,c]
------------------------------------------------------------------------------------
EvaQueryStatus EvaQuery(uint16_t command, const uint8_t *query, uint8_t *outbuffer);
------------------------------------------------------------------------------------

Uname
-----
Versione del kernel Evangelion

Livello Sicurezza: `APPLICATION`
[source,c]
---------------------
SyscallUname Uname();
---------------------

Sysinfo
-------
Informazioni di sistema

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------
SyscallSysinfo Sysinfo();
-------------------------

RebootSystem
------------
Riavvia il sistema

Livello Sicurezza: `KERNEL`
[source,c]
--------------------
void RebootSystem();
--------------------

ShutdownSystem
---------------
Spegne il sistema

Livello Sicurezza: `KERNEL`
[source,c]
----------------------
void ShutdownSystem();
----------------------

Sound
-----
Suona una frequenza con il buzz del computer

Parametro: `frequency`
		Frequenza che vuoi riprodurre

Livello Sicurezza: `APPLICATION`
[source,c]
-------------------------------
void Sound(uint32_t frequency);
-------------------------------

SoundMute
---------
Imposta il suono a muto

Livello Sicurezza: `APPLICATION`
[source,c]
-----------------
void SoundMute();
-----------------